### 作用域和执行上下文

#### js编译过程

- 分词/词法分析，会将代码拆分成有意义（对编程）的代码单元；
- 解析/代码分析，将上一步拆分成的词法单元流转化车ast语法树；
- 代码生成，根据ast语法树生成代码指令。
- 注意：编译过程是在代码执行前执行的，编译完之后，代码一般马上执行。

### 作用域

#### 作用域
- 一种规则，定义了可以在何处访问变量
- 全局作用域
  - 代码在一开始执行时的全局环境
- 局部作用域
    - 函数作用域，执行函数时，会创建新的作用域
- 块级作用域，es6中提出
    - 一个代码块（有{}）包围的部分

#### 块级作用域

#### 作用域链

- 一般情况下，我们需要同时顾及几个作用域，比如一个块或函数在另一个块或函数内时，形成了作用域的嵌套；
- 当在内部去查询变量时，未找到，就会向外层作用域去查找，直到找到该变量或**抵达全局作用域**为止；
- 最小特权原则，从最内部开始查找

#### 改变作用域的两个机制

- eval，接受一个可执行的字符串，在当前位置，直接执行，相当于在代码执行阶段，修改了当前作用域
- with, 接收的参数即为后面代码的作用域

```
function a(obj) {
	with(obj) {
		console.log(obj.name)
	}
}
const b = {
	name: 'alvin'
}
const c = {
	name: 'bob'
}
a(c) // bob
a(b) // alvin
```

- 注意，会有**性能问题**，通常情况下，js引擎在编译时都会尽可能的优化代码，但是当使用这两种策略修改了作用域时，引擎无法确定其明确的作用域，因此会跳过某些优化，导致性能问题

#### 好处

- 隐藏变量，作用域会隐藏变量，外界无法访问到这些变量
- 规避冲突，变量都在当前作用域中使用，不会和外界的变量（变量名）冲突
  - 命名空间
  - 模块管理

##### 执行上下文
- 根据ecmascript实现的宿主环境，全局上下文的对象可能不一样。浏览器中全局上下文就是window对象
- 全局执行上下文（ecs）,js代码再开始执行时，先创建一个执行栈，在代码执行之前，会有一个代码编译阶段，预编译过程中，会将var定义的变量还有function定义的变量，先声明，再执行；
- 当执行到一个函数时，会创建一个新的局部执行上下文，并推入执行栈中，与此上下文对应的也有一个vo(virable object)，变量对象，保存着预编译时声明的一些变量和函数；
- 执行栈中，先进后出的特点；

- 执行上下文都对应着一个vo，变量对象，在此执行上下文中，就可以访问到vo里的变量，暂时理解这个vo就是作用域；当有新的局部执行上下文推到执行栈时，会在将此作用域添加到上一个作用域的前面，依次添加，即形成了作用域链；
- 当访问变量时，总是先从最近的作用域开始查找，找不到，才会向上一个作用域去找，一直到全局作用域或者找到为止

#### 注意点

- 预编译不是只执行一次的，当即将要执行代码时，先创建全局上下文，执行一次预编译，将一些全局声明的变量和函数预编译；当代码执行到函数时，会创建一个新的局部上下文，然后再执行一次预编译，依次执行的；
- 预编译时，var声明的变量，默认值是undefined；function声明的函数，默认值是后面的函数体（直接赋值了）

